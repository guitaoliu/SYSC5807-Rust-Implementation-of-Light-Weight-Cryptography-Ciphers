use rawbytes::RawBytes;

#[inline(always)]
const fn round(x: [u32; 12], c: u32) -> [u32; 12] {
    // Î¸ step
    let p = [
        x[0] ^ x[4] ^ x[8],
        x[1] ^ x[5] ^ x[9],
        x[2] ^ x[6] ^ x[10],
        x[3] ^ x[7] ^ x[11],
    ];
    let e = [
        p[3].rotate_left(5) ^ p[3].rotate_left(14),
        p[0].rotate_left(5) ^ p[0].rotate_left(14),
        p[1].rotate_left(5) ^ p[1].rotate_left(14),
        p[2].rotate_left(5) ^ p[2].rotate_left(14),
    ];

    let mut tmp = [0u32; 12];

    tmp[0] = e[0] ^ x[0] ^ c;
    tmp[1] = e[1] ^ x[1];
    tmp[2] = e[2] ^ x[2];
    tmp[3] = e[3] ^ x[3];
    tmp[4] = e[3] ^ x[7];
    tmp[5] = e[0] ^ x[4];
    tmp[6] = e[1] ^ x[5];
    tmp[7] = e[2] ^ x[6];
    tmp[8] = (e[0] ^ x[8]).rotate_left(11);
    tmp[9] = (e[1] ^ x[9]).rotate_left(11);
    tmp[10] = (e[2] ^ x[10]).rotate_left(11);
    tmp[11] = (e[3] ^ x[11]).rotate_left(11);

    [
        (!tmp[4] & tmp[8]) ^ tmp[0],
        (!tmp[5] & tmp[9]) ^ tmp[1],
        (!tmp[6] & tmp[10]) ^ tmp[2],
        (!tmp[7] & tmp[11]) ^ tmp[3],
        ((!tmp[8] & tmp[0]) ^ tmp[4]).rotate_left(1),
        ((!tmp[9] & tmp[1]) ^ tmp[5]).rotate_left(1),
        ((!tmp[10] & tmp[2]) ^ tmp[6]).rotate_left(1),
        ((!tmp[11] & tmp[3]) ^ tmp[7]).rotate_left(1),
        ((!tmp[2] & tmp[6]) ^ tmp[10]).rotate_left(8),
        ((!tmp[3] & tmp[7]) ^ tmp[11]).rotate_left(8),
        ((!tmp[0] & tmp[4]) ^ tmp[8]).rotate_left(8),
        ((!tmp[1] & tmp[5]) ^ tmp[9]).rotate_left(8),
    ]
}

#[derive(Clone, Copy, Debug, Default)]
pub struct State {
    x: [u32; 12],
}

impl State {
    pub fn new(
        x0: u32,
        x1: u32,
        x2: u32,
        x3: u32,
        x4: u32,
        x5: u32,
        x6: u32,
        x7: u32,
        x8: u32,
        x9: u32,
        x10: u32,
        x11: u32,
    ) -> Self {
        State {
            x: [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11],
        }
    }

    pub fn permute(&mut self) {
        self.x = [
            0x058, 0x038, 0x3c0, 0x0d0, 0x120, 0x014, 0x060, 0x02c, 0x380, 0x0f0, 0x1a0, 0x012,
        ]
        .into_iter()
        .fold(self.x, round);
    }

    #[inline(always)]
    fn bytes_view(&self) -> &[u8] {
        let view = RawBytes::bytes_view(&self.x);
        debug_assert_eq!(view.len(), 48);
        view
    }

    #[inline(always)]
    fn bytes_view_mut(&mut self) -> &mut [u8] {
        let view = RawBytes::bytes_view_mut(&mut self.x);
        debug_assert_eq!(view.len(), 48);
        view
    }

    #[inline(always)]
    fn endian_swap(&mut self) {
        for word in self.x.iter_mut() {
            *word = (*word).to_le()
        }
    }
    #[inline(always)]
    pub fn add_byte(&mut self, byte: u8, offset: usize) {
        self.endian_swap();
        let st_bytes = self.bytes_view_mut();
        st_bytes[offset] ^= byte;
        self.endian_swap();
    }

    #[inline(always)]
    pub fn add_bytes(&mut self, bytes: &[u8]) {
        self.endian_swap();
        let st_bytes = self.bytes_view_mut();
        for (st_byte, byte) in st_bytes.iter_mut().zip(bytes) {
            *st_byte ^= byte;
        }
        self.endian_swap();
    }

    #[inline(always)]
    pub fn extract_bytes(&mut self, out: &mut [u8]) {
        self.endian_swap();
        let st_bytes = self.bytes_view();
        out.copy_from_slice(&st_bytes[..out.len()]);
        self.endian_swap();
    }
}

impl TryFrom<&[u32]> for State {
    type Error = ();

    fn try_from(values: &[u32]) -> Result<Self, Self::Error> {
        match values.len() {
            12 => Ok(State {
                x: [
                    values[0], values[1], values[2], values[3], values[4], values[5], values[6],
                    values[7], values[8], values[9], values[10], values[11],
                ],
            }),
            _ => Err(()),
        }
    }
}

impl From<&[u32; 12]> for State {
    fn from(values: &[u32; 12]) -> Self {
        State { x: *values }
    }
}

impl TryFrom<&[u8]> for State {
    type Error = ();

    fn try_from(values: &[u8]) -> Result<Self, Self::Error> {
        if values.len() != core::mem::size_of::<u32>() * 12 {
            return Err(());
        }
        let mut state = State::default();
        for (src, dst) in values
            .chunks_exact(core::mem::size_of::<u32>())
            .zip(state.x.iter_mut())
        {
            *dst = u32::from_le_bytes(src.try_into().unwrap());
        }
        Ok(state)
    }
}

impl From<&[u8; 12 * core::mem::size_of::<u32>()]> for State {
    fn from(values: &[u8; 12 * core::mem::size_of::<u32>()]) -> Self {
        let mut state = State::default();
        for (src, dst) in values
            .chunks_exact(core::mem::size_of::<u32>())
            .zip(state.x.iter_mut())
        {
            *dst = u32::from_le_bytes(src.try_into().unwrap());
        }
        state
    }
}

impl AsRef<[u32]> for State {
    fn as_ref(&self) -> &[u32] {
        &self.x
    }
}

impl core::ops::Index<usize> for State {
    type Output = u32;

    fn index(&self, index: usize) -> &Self::Output {
        &self.x[index]
    }
}

impl core::ops::IndexMut<usize> for State {
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        &mut self.x[index]
    }
}

impl PartialEq for State {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x
    }
}

#[cfg(test)]
mod test {

    use super::*;

    #[derive(Debug)]
    struct PermutationTest {
        input: [u8; 48],
        expected: [u8; 48],
    }

    #[test]
    fn test_permute_12() {
        let test_table = [
            PermutationTest {
                input: [
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ],
                expected: [
                    0x8D, 0xD8, 0xD5, 0x89, 0xBF, 0xFC, 0x63, 0xA9, 0x19, 0x2D, 0x23, 0x1B, 0x14,
                    0xA0, 0xA5, 0xFF, 0x06, 0x81, 0xB1, 0x36, 0xFE, 0xC1, 0xC7, 0xAF, 0xBE, 0x7C,
                    0xE5, 0xAE, 0xBD, 0x40, 0x75, 0xA7, 0x70, 0xE8, 0x86, 0x2E, 0xC9, 0xB7, 0xF5,
                    0xFE, 0xF2, 0xAD, 0x4F, 0x8B, 0x62, 0x40, 0x4F, 0x5E,
                ],
            },
            PermutationTest {
                input: [
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
                    0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
                    0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
                    0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
                ],
                expected: [
                    0x76, 0x33, 0xAE, 0xB5, 0x5D, 0xCC, 0xBF, 0x60, 0xD4, 0xA6, 0xDF, 0xD7, 0x50,
                    0x6D, 0x06, 0xBF, 0xB2, 0xAC, 0x97, 0xAE, 0x97, 0x0D, 0x8A, 0xD3, 0x13, 0x85,
                    0x11, 0x7B, 0xB7, 0x75, 0xA7, 0x41, 0xB3, 0xB1, 0x54, 0x0B, 0xB5, 0x3B, 0xE9,
                    0x6F, 0x3B, 0x2B, 0x8F, 0xAF, 0xA6, 0x76, 0xA3, 0xB6,
                ],
            },
        ];

        for test in test_table.iter() {
            let mut state = State::from(&test.input);
            state.permute();
            assert_eq!(state, State::from(&test.expected));
        }
    }

    struct AddByteTest {
        input: [u8; 48],
        byte: u8,
        offset: usize,
        expected: [u8; 48],
    }

    #[test]
    fn test_add_byte() {
        let test_table = [
            AddByteTest {
                input: [
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ],
                byte: 0xff,
                offset: 0,
                expected: [
                    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ],
            },
            AddByteTest {
                input: [
                    0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ],
                byte: 0x33,
                offset: 0,
                expected: [
                    0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ],
            },
            AddByteTest {
                input: [
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55,
                ],
                byte: 0xAA,
                offset: 47,
                expected: [
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
                ],
            },
            AddByteTest {
                input: [
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ],
                byte: 0x66,
                offset: 3,
                expected: [
                    0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ],
            },
        ];

        for test in test_table.iter() {
            let mut state = State::from(&test.input);
            state.add_byte(test.byte, test.offset);
            assert_eq!(state, State::from(&test.expected));
        }
    }

    #[test]
    fn test_add_bytes() {
        let initial_state: [u8; 48] = [
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        ];
        let mut state = State::from(&initial_state);

        let input: [u8; 48] = [
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
            0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
            0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
            0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        ];

        let expected: [u8; 48] = [
            0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9,
            0xf8, 0xf7, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xfe, 0xfd, 0xfc, 0xfb,
            0xfa, 0xf9, 0xf8, 0xf7, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xfe, 0xfd,
            0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7,
        ];

        state.add_bytes(&input);
        assert_eq!(state, State::from(&expected));
    }
}
